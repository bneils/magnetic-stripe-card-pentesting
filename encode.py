# The first bit in the tables is the MSB and makes the number of 1s in the string odd.

# Table 1 isn't used, but is here for future use
table_t1 = {
    " ": "1000000",
    "!": "0000001", # hardware control
    "\"":"0000010", # hardware control
    "#": "1000011", # reserved for optional additional graphic symbols
    "$": "0000100",
    "%": "1000101", # start sentinel
    "&": "1000110", # hardware control
    "'": "0000111", # hardware control
    "(": "0001000",
    ")": "1001001",
    "*": "1001010", # hardware control
    "+": "0001011", # hardware control
    ",": "1001100", # hardware control
    "-": "0001101",
    ".": "0001110",
    "/": "1001111",
    "0": "0010000",
    "1": "1010001",
    "2": "1010010",
    "3": "0010011",
    "4": "1010100",
    "5": "0010101",
    "6": "0010110",
    "7": "1010111",
    "8": "1011000",
    "9": "0011001",
    ":": "0011010", # hardware control
    ";": "1011011", # hardware control
    "<": "0011100", # hardware control
    "=": "1011101", # hardware control
    ">": "1011110", # hardware control
    "?": "0011111", # end sentinel
    "@": "0100000", # hardware control
    "A": "1100001",
    "B": "1100010",
    "C": "0100011",
    "D": "1100100",
    "E": "0100101",
    "F": "0100110",
    "G": "1100111",
    "H": "1101000",
    "I": "0101001",
    "J": "0101010",
    "K": "1101011",
    "L": "0101100",
    "M": "1101101",
    "N": "1101110",
    "O": "0101111",
    "P": "1110000",
    "Q": "0110001",
    "R": "0110010",
    "S": "1110011",
    "T": "0110100",
    "U": "1110101",
    "V": "1110110",
    "W": "0110111",
    "X": "0111000",
    "Y": "1111001",
    "Z": "1111010",
    "[": "0111011", # <-- reserved for additional national characters
    "\\":"1111100", # <-- when required (no international)
    "]": "0111101", # <--
    "^": "0111110", # field separator
    "_": "1111111", # hardware control
}

table_t2 = {
    "0": "10000", # data ...
    "1": "00001",
    "2": "00010",
    "3": "10011",
    "4": "00100",
    "5": "10101",
    "6": "10110",
    "7": "00111",
    "8": "01000",
    "9": "11001",
    ":": "11010", # hardware control
    ";": "01011", # start sentinel
    "<": "11100", # hardware control
    "=": "01101", # field sep
    ">": "01110", # hardware control
    "?": "11111", # end sentinel
}

def LRC(d, table):
    """Computes the Longitudinal Redundancy Check for ASCII data using a table """
    val = 0
    for ch in d:
        if ch not in table: # skip pipe, if there
            continue
        val ^= int(table[ch][1:], 2) # discard parity bit before xor process
    # prepend parity bit
    val |= (bin(val).count("1") % 2 == 0) << (len(table["0"]) - 1)
    for k, v in table.items():
        if int(v, 2) == val:
            return k

def get_track2(pan: str):
    track = ";{0}=49121010000000000000?".format(int(pan))
    return track + LRC(track, table_t2)

# Most of the time readers don't actually read the first track, so this step
# is actually somewhat redundant
def get_track1(ubid: str, last_name: str, pan: str):

    track = "%B{0}^{1}/^49121010000000{2}0000000?" \
        .format(pan, last_name.upper().ljust(25, " "), ubid)
    return track + LRC(track, table_t1)

def merge_tracks(t1, t2, t3=""):
    return t1 + "|" + t2 + "|" + t3
